{"history":[{"breakpoints":[{"props":{"fitToCanvas":1,"translateX":0,"translateY":-0.5,"opacity":1,"size":0.729},"min":992,"name":"Desktop","max":null}],"visible":true,"locked":false,"aspectRatio":1,"layerName":"","isElement":true,"opacity":1,"displace":0,"trackMouse":0,"mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"image","imageLoaded":false,"effects":[],"size":0.729,"rotation":0,"height":1038,"fitToCanvas":1,"scaleX":1,"scaleY":1,"src":"https://assets.unicorn.studio/images/JvyMwZcNgQfs53gbk8chlfW1W5D3/Frame 23 (17).png","translateX":0,"translateY":-0.5,"width":1920,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * 1.00);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"]},{"breakpoints":[{"props":{"frequency":1,"speed":0.13,"amount":0.07,"angle":0,"pos":{"type":"Vec2","_x":0.4872093023255814,"_y":0.5558889722430608},"scale":0.37,"texture":["https://firebasestorage.googleapis.com/v0/b/unicorn-studio.appspot.com/o/JvyMwZcNgQfs53gbk8chlfW1W5D3%2Flady-map%20(4)_%40thumbnail.png?alt=media&token=effecc31-bbda-45ea-b6b1-9e2821beb077","uCustomTexture","https://assets.unicorn.studio/images/JvyMwZcNgQfs53gbk8chlfW1W5D3/lady-map (4).png","lady-map (4).png"],"mouseMomentum":0.43},"min":992,"max":null,"name":"Desktop"},{"min":576,"max":991,"props":{"scale":0.37,"texture":["https://firebasestorage.googleapis.com/v0/b/unicorn-studio.appspot.com/o/JvyMwZcNgQfs53gbk8chlfW1W5D3%2Flady-map%20(4)_%40thumbnail.png?alt=media&token=effecc31-bbda-45ea-b6b1-9e2821beb077","uCustomTexture","https://assets.unicorn.studio/images/JvyMwZcNgQfs53gbk8chlfW1W5D3/lady-map (4).png","lady-map (4).png"]},"name":"Tablet"},{"max":575,"name":"Mobile","props":{"texture":["https://firebasestorage.googleapis.com/v0/b/unicorn-studio.appspot.com/o/JvyMwZcNgQfs53gbk8chlfW1W5D3%2Flady-map%20(4)_%40thumbnail.png?alt=media&token=effecc31-bbda-45ea-b6b1-9e2821beb077","uCustomTexture","https://assets.unicorn.studio/images/JvyMwZcNgQfs53gbk8chlfW1W5D3/lady-map (4).png","lady-map (4).png"]},"min":0}],"visible":true,"aspectRatio":1,"layerType":"effect","type":"custom","texture":{"thumb":"https://firebasestorage.googleapis.com/v0/b/unicorn-studio.appspot.com/o/JvyMwZcNgQfs53gbk8chlfW1W5D3%2Flady-map%20(4)_%40thumbnail.png?alt=media&token=effecc31-bbda-45ea-b6b1-9e2821beb077","sampler":"uCustomTexture","src":"https://assets.unicorn.studio/images/JvyMwZcNgQfs53gbk8chlfW1W5D3/lady-map (4).png","name":"lady-map (4).png"},"speed":0.13,"mouseMomentum":0.43,"animating":true,"isMask":0,"customFragmentShaders":["#version 300 es\nprecision mediump float;\n\n// Input texture coordinates from the vertex shader\nin vec2 vTextureCoord;\n\n// Define the uniforms\nuniform vec2 uResolution;     // width and height of the screen\nuniform vec2 uMousePos;       // mouse position\nuniform float uAmount;        // scale factor for the 3D effect intensity\nuniform sampler2D uTexture;   // main texture\nuniform sampler2D uCustomTexture; // depth map\n\n// Define the output color\nout vec4 fragColor;\n\n// Function to handle mirrored UVs\nvec2 mirrored(vec2 v) {\n  vec2 m = mod(v, 2.0);\n  return mix(m, 2.0 - m, step(1.0, m));\n}\n\nvoid main() {\n  // Calculate aspect ratios\n  float textureAspectRatio = float(textureSize(uCustomTexture, 0).x) / float(textureSize(uCustomTexture, 0).y);\n  float windowAspectRatio = uResolution.x / uResolution.y;\n\n  // Determine the scaling factor and offsets\n  vec2 scale = vec2(1.0);\n  vec2 offset = vec2(0.0);\n\n  if (windowAspectRatio > textureAspectRatio) {\n    scale.y = textureAspectRatio / windowAspectRatio;\n    offset.y = (1.0 - scale.y) * 0.5;\n  } else {\n    scale.x = windowAspectRatio / textureAspectRatio;\n    offset.x = (1.0 - scale.x) * 0.5;\n  }\n\n  // Adjust and center the texture coordinates\n  vec2 adjustedUv = vTextureCoord * scale + offset;\n\n  // Get the texture from the depth map\n  vec4 depthMap = texture(uCustomTexture, mirrored(adjustedUv));\n\n  // Calculate the fake 3D offset\n  vec2 offset3D = (depthMap.r - 0.5) * uAmount * (uMousePos - vec2(0.5));\n\n  // Apply the fake 3D offset\n  vec2 fake3D = vTextureCoord + offset3D;\n\n  // Get the color from the main texture using the fake 3D coordinates\n  vec4 color = texture(uTexture, mirrored(fake3D));\n\n  // Set the output color of our pixel to the main texture color\n  fragColor = color;\n}\n"],"customVertexShaders":["#version 300 es\nprecision mediump float;\n\nin vec3 aVertexPosition;  // Vertex position input\nin vec2 aTextureCoord;    // Texture coordinates input\n\nout vec2 vTextureCoord;   // Pass texture coordinates to the fragment shader\n\nvoid main() {\n    // Set the position of the vertex in normalized device coordinates (NDC)\n    gl_Position = vec4(aVertexPosition, 1.0);\n\n    // Pass the texture coordinates to the fragment shader\n    vTextureCoord = aTextureCoord;\n}\n"],"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform vec2 uResolution; uniform vec2 uMousePos; uniform sampler2D uTexture; uniform sampler2D uCustomTexture;out vec4 fragColor;vec2 mirrored(vec2 v) { vec2 m = mod(v, 2.0); return mix(m, 2.0 - m, step(1.0, m)); }void main() { float textureAspectRatio = float(textureSize(uCustomTexture, 0).x) / float(textureSize(uCustomTexture, 0).y); float windowAspectRatio = uResolution.x / uResolution.y; vec2 scale = vec2(1.0); vec2 offset = vec2(0.0);if (windowAspectRatio > textureAspectRatio) { scale.y = textureAspectRatio / windowAspectRatio; offset.y = (1.0 - scale.y) * 0.5; } else { scale.x = windowAspectRatio / textureAspectRatio; offset.x = (1.0 - scale.x) * 0.5; } vec2 adjustedUv = vTextureCoord * scale + offset; vec4 depthMap = texture(uCustomTexture, mirrored(adjustedUv)); vec2 offset3D = (depthMap.r - 0.5) * 0.07 * (uMousePos - vec2(0.5)); vec2 fake3D = vTextureCoord + offset3D; vec4 color = texture(uTexture, mirrored(fake3D)); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;out vec2 vTextureCoord;void main() { gl_Position = vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false,"uniforms":{"scale":{"name":"uScale","type":"1f","value":0.5}}}},{"breakpoints":[{"max":null,"props":{"translateY":22,"rotation":0,"size":0.6920000000000001,"translateX":7,"trackMouse":0},"name":"Desktop","min":992},{"min":576,"props":{"translateY":123,"translateX":6},"max":991,"name":"Tablet"},{"max":575,"min":0,"props":{"translateY":222,"translateX":4},"name":"Mobile"}],"visible":true,"locked":false,"aspectRatio":1,"layerName":"","isElement":true,"opacity":1,"displace":0,"trackMouse":0,"mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"image","imageLoaded":false,"effects":[],"size":0.6920000000000001,"rotation":0,"height":1038,"fitToCanvas":false,"scaleX":1,"scaleY":1,"src":"https://assets.unicorn.studio/images/JvyMwZcNgQfs53gbk8chlfW1W5D3/Hero (15).png","translateX":7,"translateY":22,"width":1920,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * 1.00);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"]},{"breakpoints":[{"max":null,"props":{"mouseMomentum":1,"specular":0.2,"pos":{"type":"Vec2","_x":0.48488372093023246,"_y":0.6311241271856425},"ambient":1,"scale":0.526,"intensity":0.21,"trackMouse":1},"name":"Desktop","min":992}],"visible":true,"aspectRatio":1,"layerType":"effect","type":"spotlight","trackMouse":1,"mouseMomentum":1,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor;const int kernelSize = 36; const float gaussianWeights[kernelSize] = float[](0.00094768, 0.00151965, 0.00237008, 0.00359517, 0.0053041, 0.00761097, 0.01062197, 0.01441804, 0.01903459, 0.0244409, 0.03052299, 0.03707432, 0.04379813, 0.05032389, 0.05623791, 0.06112521, 0.06461716, 0.06643724, 0.06643724, 0.06461716, 0.06112521, 0.05623791, 0.05032389, 0.04379813, 0.03707432, 0.03052299, 0.0244409, 0.01903459, 0.01441804, 0.01062197, 0.00761097, 0.0053041, 0.00359517, 0.00237008, 0.00151965, 0.00094768);vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float weightSum = 0.0;float amount = (0.50 + 0.1) * 2.; float aspectRatio = uResolution.x/uResolution.y;direction.x /= aspectRatio;color += texture(tex, uv) * gaussianWeights[0]; for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x/1000.) * direction) * gaussianWeights[i]; } return color; }float getHeight(vec2 uv) { vec4 col = texture(uTexture, uv); return col.r; }vec4 computeNoise(vec2 uv) { vec2 ste = (1. / uResolution); float height = getHeight(uv); vec2 dxy = height - vec2(getHeight(uv + vec2(ste.x, 0.)), getHeight(uv + vec2(0., ste.y)));return vec4(normalize(vec3(dxy * (0.02 + 0.04 * 0.50) / ste, 2.)), height); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float light(vec3 p, vec3 normal, vec3 lightPos) { vec3 direction = normalize(lightPos - p); float specular = 0.5 * pow(max(dot(direction, reflect(-direction, normal)), 0.0), 2.0); return max(0.1, dot(normal, direction) * 1.2 - specular); }void main() { vec2 uv = vTextureCoord; vec4 color;if(0.00 == 0.) { color = GaussianBlur(uTexture, uv, vec2(uResolution.y/uResolution.x, 0)); } else if(0.00 == 1.) { color = GaussianBlur(uTexture, uv, vec2(0, 1)); color.rgb += (random(gl_FragCoord.xy) - 0.1) / 255.0; } else { vec2 pos = vec2(0.48488372093023246, 0.3688758728143575) + mix(vec2(0), (uMousePos-0.5), 1.00); vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1); color = texture(uBgTexture, uv); float luma = color.r; float dist = distance(uv * aspectRatio, pos * aspectRatio) / (0.53 + 0.5); float hightlighDist = distance(uv * aspectRatio, pos * aspectRatio) / (0.53 + 0.5)/2.; float spot = max(0., max(0., (1.-dist)) * max(0., (1.-dist))); float highlightSpot = max(0., max(0., (1.-hightlighDist)) * max(0., (1.-hightlighDist))); vec3 normal = computeNoise(uv).rgb*luma; vec2 lightDir = pos * aspectRatio - uv * aspectRatio; float lightDistance = 1.-length(lightDir); lightDir = normalize(lightDir); vec3 diff = vec3(max(dot(normal, vec3(lightDir, 0.5)), 0.0));float specular = light(vec3(uv, 1.), normal, vec3(pos, 1.)); specular = smoothstep(0., 1., specular) * 2.; float intensity = 0.21 * 3.; vec3 base = color.rgb * vec3(0.7019607843137254, 0.29411764705882354, 0) * max(0., spot) * intensity; color.rgb = color.rgb * 1.00 + base * diff * vec3(0.7019607843137254, 0.29411764705882354, 0) * max(0., spot) * intensity; color.rgb += specular * vec3(0.7019607843137254, 0.29411764705882354, 0) * max(0., spot * 4.) * 0.20; color.rgb = Tonemap_tanh(color.rgb); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; } fragColor = color;}","#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor;const int kernelSize = 36; const float gaussianWeights[kernelSize] = float[](0.00094768, 0.00151965, 0.00237008, 0.00359517, 0.0053041, 0.00761097, 0.01062197, 0.01441804, 0.01903459, 0.0244409, 0.03052299, 0.03707432, 0.04379813, 0.05032389, 0.05623791, 0.06112521, 0.06461716, 0.06643724, 0.06643724, 0.06461716, 0.06112521, 0.05623791, 0.05032389, 0.04379813, 0.03707432, 0.03052299, 0.0244409, 0.01903459, 0.01441804, 0.01062197, 0.00761097, 0.0053041, 0.00359517, 0.00237008, 0.00151965, 0.00094768);vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float weightSum = 0.0;float amount = (0.50 + 0.1) * 2.; float aspectRatio = uResolution.x/uResolution.y;direction.x /= aspectRatio;color += texture(tex, uv) * gaussianWeights[0]; for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x/1000.) * direction) * gaussianWeights[i]; } return color; }float getHeight(vec2 uv) { vec4 col = texture(uTexture, uv); return col.r; }vec4 computeNoise(vec2 uv) { vec2 ste = (1. / uResolution); float height = getHeight(uv); vec2 dxy = height - vec2(getHeight(uv + vec2(ste.x, 0.)), getHeight(uv + vec2(0., ste.y)));return vec4(normalize(vec3(dxy * (0.02 + 0.04 * 0.50) / ste, 2.)), height); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float light(vec3 p, vec3 normal, vec3 lightPos) { vec3 direction = normalize(lightPos - p); float specular = 0.5 * pow(max(dot(direction, reflect(-direction, normal)), 0.0), 2.0); return max(0.1, dot(normal, direction) * 1.2 - specular); }void main() { vec2 uv = vTextureCoord; vec4 color;if(1.00 == 0.) { color = GaussianBlur(uTexture, uv, vec2(uResolution.y/uResolution.x, 0)); } else if(1.00 == 1.) { color = GaussianBlur(uTexture, uv, vec2(0, 1)); color.rgb += (random(gl_FragCoord.xy) - 0.1) / 255.0; } else { vec2 pos = vec2(0.48488372093023246, 0.3688758728143575) + mix(vec2(0), (uMousePos-0.5), 1.00); vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1); color = texture(uBgTexture, uv); float luma = color.r; float dist = distance(uv * aspectRatio, pos * aspectRatio) / (0.53 + 0.5); float hightlighDist = distance(uv * aspectRatio, pos * aspectRatio) / (0.53 + 0.5)/2.; float spot = max(0., max(0., (1.-dist)) * max(0., (1.-dist))); float highlightSpot = max(0., max(0., (1.-hightlighDist)) * max(0., (1.-hightlighDist))); vec3 normal = computeNoise(uv).rgb*luma; vec2 lightDir = pos * aspectRatio - uv * aspectRatio; float lightDistance = 1.-length(lightDir); lightDir = normalize(lightDir); vec3 diff = vec3(max(dot(normal, vec3(lightDir, 0.5)), 0.0));float specular = light(vec3(uv, 1.), normal, vec3(pos, 1.)); specular = smoothstep(0., 1., specular) * 2.; float intensity = 0.21 * 3.; vec3 base = color.rgb * vec3(0.7019607843137254, 0.29411764705882354, 0) * max(0., spot) * intensity; color.rgb = color.rgb * 1.00 + base * diff * vec3(0.7019607843137254, 0.29411764705882354, 0) * max(0., spot) * intensity; color.rgb += specular * vec3(0.7019607843137254, 0.29411764705882354, 0) * max(0., spot * 4.) * 0.20; color.rgb = Tonemap_tanh(color.rgb); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; } fragColor = color;}","#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor;const int kernelSize = 36; const float gaussianWeights[kernelSize] = float[](0.00094768, 0.00151965, 0.00237008, 0.00359517, 0.0053041, 0.00761097, 0.01062197, 0.01441804, 0.01903459, 0.0244409, 0.03052299, 0.03707432, 0.04379813, 0.05032389, 0.05623791, 0.06112521, 0.06461716, 0.06643724, 0.06643724, 0.06461716, 0.06112521, 0.05623791, 0.05032389, 0.04379813, 0.03707432, 0.03052299, 0.0244409, 0.01903459, 0.01441804, 0.01062197, 0.00761097, 0.0053041, 0.00359517, 0.00237008, 0.00151965, 0.00094768);vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float weightSum = 0.0;float amount = (0.50 + 0.1) * 2.; float aspectRatio = uResolution.x/uResolution.y;direction.x /= aspectRatio;color += texture(tex, uv) * gaussianWeights[0]; for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x/1000.) * direction) * gaussianWeights[i]; } return color; }float getHeight(vec2 uv) { vec4 col = texture(uTexture, uv); return col.r; }vec4 computeNoise(vec2 uv) { vec2 ste = (1. / uResolution); float height = getHeight(uv); vec2 dxy = height - vec2(getHeight(uv + vec2(ste.x, 0.)), getHeight(uv + vec2(0., ste.y)));return vec4(normalize(vec3(dxy * (0.02 + 0.04 * 0.50) / ste, 2.)), height); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float light(vec3 p, vec3 normal, vec3 lightPos) { vec3 direction = normalize(lightPos - p); float specular = 0.5 * pow(max(dot(direction, reflect(-direction, normal)), 0.0), 2.0); return max(0.1, dot(normal, direction) * 1.2 - specular); }void main() { vec2 uv = vTextureCoord; vec4 color;if(2.00 == 0.) { color = GaussianBlur(uTexture, uv, vec2(uResolution.y/uResolution.x, 0)); } else if(2.00 == 1.) { color = GaussianBlur(uTexture, uv, vec2(0, 1)); color.rgb += (random(gl_FragCoord.xy) - 0.1) / 255.0; } else { vec2 pos = vec2(0.48488372093023246, 0.3688758728143575) + mix(vec2(0), (uMousePos-0.5), 1.00); vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1); color = texture(uBgTexture, uv); float luma = color.r; float dist = distance(uv * aspectRatio, pos * aspectRatio) / (0.53 + 0.5); float hightlighDist = distance(uv * aspectRatio, pos * aspectRatio) / (0.53 + 0.5)/2.; float spot = max(0., max(0., (1.-dist)) * max(0., (1.-dist))); float highlightSpot = max(0., max(0., (1.-hightlighDist)) * max(0., (1.-hightlighDist))); vec3 normal = computeNoise(uv).rgb*luma; vec2 lightDir = pos * aspectRatio - uv * aspectRatio; float lightDistance = 1.-length(lightDir); lightDir = normalize(lightDir); vec3 diff = vec3(max(dot(normal, vec3(lightDir, 0.5)), 0.0));float specular = light(vec3(uv, 1.), normal, vec3(pos, 1.)); specular = smoothstep(0., 1., specular) * 2.; float intensity = 0.21 * 3.; vec3 base = color.rgb * vec3(0.7019607843137254, 0.29411764705882354, 0) * max(0., spot) * intensity; color.rgb = color.rgb * 1.00 + base * diff * vec3(0.7019607843137254, 0.29411764705882354, 0) * max(0., spot) * intensity; color.rgb += specular * vec3(0.7019607843137254, 0.29411764705882354, 0) * max(0., spot * 4.) * 0.20; color.rgb = Tonemap_tanh(color.rgb); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; } fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"passes":[{"prop":"pass","value":1},{"prop":"pass","value":2,"includeBg":true}]}}],"options":{"name":"Untitled project","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false,"version":"1.3.1"},"version":"1.3.2"}
